데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소를 꼽으라면 바로 **확장성(Scalability)**과 **가용성(Availablity)**이다. 서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해 가장 일반적으로 사용되는 기술이 바로 **복제(Replication)**이다.

# 복제(Replication)란?

복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말하며, 원본 데이터를 가진 서버를 **소스(Source) 서버 또는 마스터 서버**, 복제된 데이터를 가지는 서버를 **레플리카(Replica) 서버 또는 슬레이브 서버**라고 부른다. 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 이러한 변경 내역을 소스 서버로부터 전달받아 데이터를 동기화 시킨다.

레플리카 서버를 구축하는 데는 다음과 같은 목적이 있다.

1. 스케일 아웃(Scale-out)
    - 서비스를 운영하다 보면 사용자가 늘어나고, 이에 따라 DB 서버로 유입되는 트래픽도 자연히 증가해 DB 서버의 부하가 높아진다.
    - 이런 부하를 감당하기 위해서 DB 서버의 성능을 높이는 **스케일 업(Scale-up)** 방식을 쓸 수 있지만 결국 한 대가 처리할 수 있는 양에는 한계가 있다는 단점이 있다.
    - 만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로 부터 오는 쿼리를 분산시킬 수 있다. 이 방법을 **스케일 아웃(Scale-out)**이라고 한다.

![image](https://user-images.githubusercontent.com/89899249/185542037-ebaea2df-ef7d-429b-9eb7-2ff7d4a4bbad.png)

1. 데이터 백업
    - DB 서버의 데이터가 사용자의 실수로 삭제되면 서비스 운영에 큰 영향을 미친다.
    - 이러한 경우를 대비해서 DB 서버에 저장된 데이터를 주기적으로 백업하는 용도로 레플리카 서버를 사용한다.

![image](https://user-images.githubusercontent.com/89899249/185542108-6331eb0f-65cc-41e6-aa54-dab5c6ec0bbb.png)

1. 데이터 분석
    - DB 서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행지만 서비스를 좀 더 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다.
    - 분석용 쿼리는 복잡하고 무거운 경우가 대부분이라서 DB 서버에서 하기에는 서버에 무리가 많이 같다.
    - 이러한 경우를 대비해서 분석용 쿼리는 여분의 레플리카 서버에서 실행하는 것이 좋다.
2. 데이터의 지리적 분산
    - 애플리케이션 서버와 DB 서버의 거리가 먼 경우 두 서버의 통신 시간은떨어진 거리에 비례해서 늘어난다.
    - 따라서 애플리케이션 서버가 위치한 곳에 레플리카 서버를 구축해 응답 속도를 개선할 수 있다.
    

# 복제 아키텍처

- MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 **바이너리 로그(Binary Log)**라고 한다.
- 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구저 변경과 계정이나 권한의 변경 정보까지 모두 저장된다.
- MySQL 복제는 이 바이너리 로그를 기반으로 구현됐는데, 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 데이터 동기화에 사용한다.
- 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 로컬 디스크에 저장해둔 파일을 릴레이 로그(Relay Log)라 한다.

아래 그림은 복제 동기화가 처리되는 전반적인 과정을 보여준다.

![image](https://user-images.githubusercontent.com/89899249/185542192-64e799ca-3626-47fe-8c3c-0415adf675e0.png)

MySQL 복제는 세 개의 스레드에 의해 작동한다. 이 중 하나는 소스 서버에 존재하며, 나머지 두 개의 스레드는 레플리카 서버에 존재한다. 각 스레드의 역할을 다음과 같다.

- 바이너리 로그 덤프 스레드
    - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청한다.
    - 이때 소스 서버에서는 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다.
    - 이 과정을 수행할 때, 바이너리 로그에 잠금이 걸리고 과정이 모두 끝나면 잠금을 해제한다.
- 레플리케이션 I/O 스레드
    - 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다.
    - I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그를 가져와 로컬 서버의 파일(릴레이 로그)로 저장하는 역할을 담당한다.
- 레플리케이션 SQL 스레드
    - 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 릭고 실행한다.

각 스레드 들의 특징은 다음과 같다.

- 레플리카 서버의 스레드들은 서로 독립적으로 동작한다. 그러므로 만약 SQL 스레드가 느리게 동작한다고 해도 I/O 스레드는 그것과 무관하게 정상적으로 빠르게 동작할 수 있다.
- 레플리카 서버에 문제가 생기더라도 소스 서버는 전혀 영향을 받지 않는다.
- 소스 서버에 문제가 생겨 레플리카 서버의 I/O 스레드가 정상적으로 작동하지 않으면 복제는 에러를 발생시키고 바로 중단된다. 그러나 레플리카 서버의 복제 기능만 중단된 것이기 때문에 쿼리 처리는 정상적으로 동작한다.

# 복제 타입

MySQL의 복제는 소스 서버의 바이너리 로그에 기록된 변경 내역들을 식별하는 방식에 따라 다음과 같이 나누어진다.

- 바이너리 로그 파일 위치 기반 복제
- 글로벌 트랜잭션 ID 기반 복제

각 방식의 동작 원리와 구축 방법을 살펴보겠다.

## 바이너리 로그 파일 위치 기반 복제

### 설정 준비

기본적으로 MySQL 복제를 사용하려면 소스 서버에서 반드시 바이너리 로그가 활성화돼 있어야 한다. 또한 복제 구성원이 되는 각 MySQL 서버가 고유한 server_id 값을 가져야 한다. 참고로, MySQL 8.0은 바이너리 로그가 기본적으로 활성화돼 있어 server_id만 설정해도 복제는 가능하다.

Replication을 설정하려면 소스 서버의 my.cnf 파일을 아래와 같이 수정해야 한다.

**소스 서버 설정**

```bash
[mysqld]
server-id=1 ## 레플리카 서버의 server-id와 달라야 한다.
log-bin=/usr/local/mysql/logs/binlog ## log-bin 저장 경로
sync_binlog=1
binlog_cache_size=2M
max_binlog_size=512M
expire_logs_days=7
```

소스 서버를 재시작 한 후 바이너리 로그가 정상적으로 기록되고 있는지 아래 명령어를 통해 확인하자.

```bash
// 명령어
show master status;
show master status\G;

// 결과
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000004 |      978 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

레플리카 서버도 마찬가지로 my.cnf 파일을 수정해야 한다.

**레플리카 서버 설정**

```bash
server-id=2  ## 소스 서버의 server-id와 달라야 한다.
relay-log=/usr/local/mysql/logs/relay_log  ## 릴레이 로그 저장경로
relay_log_purge=true  ## 릴레이 로그 저장여부
log_slave_updates=ON  ## 복제에 의한 데이터 변경을 자신의 바이너리 로그에 기록
read_only
```

### 복제 계정 준비

레플리케 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야 하므로 접속 시 사용할 DB 계정이 필요하다.

소스 서버에 새로운 계정을 만들어 본제 관련 권한만 추가하자.

```sql
mysql> create user 'repl_user'@'%' identified by '패스워드';
mysql> grant replication slave on *.* to 'repl_user'@'%';
```

### 복제 설정 명령

아래 명령어를 입력해 복제 설정을 추가하면 된다.

```sql
change replication source to
 source_host='source server host',
 source_port=3306,
 source_user='repl_user',
 source_password='1234',
 source_log_file='mysql-bin-changelog.000022',
 source_log_pos=533,
 get_source_public_key=1;  ## RSA 키 기반의 비밀번호 교환 방식 사용 여부, 1 - 사용 X
```

이때, source_log_file과 source_log_pos는 소스 서버에서 `show master status\G` 명령어를 입력하여 출력된 정보를 적어주면 된다.

### 복제 확인

레플리카 서버에서 `show replica status\G` 명령어를 입력하면 아래와 같이 출력된다.

![image](https://user-images.githubusercontent.com/89899249/185542329-8e490383-c2c1-4359-86bd-244484bbf72d.png)

`Replica_IO_Running`과 `Replica_SQL_Running` 컬럼값이 Yes로 출력되면 소스 서버와의 동기화가 잘 이뤄진 것이다.

소스 서버에 직접 데이터를 삽입하면 레플리카 서버에도 동일한 데이터가 삽입된 것을 확인할 수 있다.

## 참고

- Real MySQL
- [https://rlawls1991.tistory.com/entry/MySQL-Replication](https://rlawls1991.tistory.com/entry/MySQL-Replication)
- [https://devlog-wjdrbs96.tistory.com/371?category=950229](https://devlog-wjdrbs96.tistory.com/371?category=950229)
- [https://hoing.io/archives/3111](https://hoing.io/archives/3111)
- [https://jupiny.com/2017/11/07/docker-mysql-replicaiton/](https://jupiny.com/2017/11/07/docker-mysql-replicaiton/)
- [https://danidani-de.tistory.com/28](https://danidani-de.tistory.com/28)
