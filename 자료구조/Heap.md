# 힙

## 힙(Heap) 이란?
최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리입니다.

> **완전 이진 트리**  
> 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리

## 힙(Heap)을 사용하는 이유
* 배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n) 이 걸립니다.
* 이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, O(log n)이 걸립니다.
* 따라서, 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됩니다.

> **우선순위 큐**  
> 우선순위의 개념을 큐에 도입한 자료구조입니다. 따라서, 데이터들이 우선순위를 갖고 있어 우선순위가 높은 데이터가 먼저 나가도록 설계되어 있습니다.

## 힙(Heap)의 종류

### 최대 힙(Max Heap)
부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리입니다.
 
### 최소 힙(Min Heap)
부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리


## 힙(Heap)의 구현
* 힙을 저장하는 표준적인 자료구조는 배열입니다.
* 구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않고 1번부터 사용됩니다.
* 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않습니다. 예를 들어, 루트 노드는 항상 배열의 1번 인덱스이고 루트 노드의 왼쪽 자식은 2번 인덱스, 오른쪽 자식은 3번 인덱스입니다. 힙에 삽입과 삭제가 일어나도 변경되지 않습니다.
* 부모 노드와 자식 노드의 관계
  * 부모 노드 인덱스 번호 = 자식 노드 인덱스 번호 / 2
  * 왼쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2
  * 오른쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2 + 1
  * ![image](https://user-images.githubusercontent.com/55661631/140632898-6cc5914c-87cc-47f1-aa95-db36b6ae885d.png)

## 힙(Heap)의 동작

### 힙(Heap)에 데이터 삽입하기

1. 위에서 말씀드린대로 힙은 완전 이진 트리이므로, 데이터가 삽입되면 왼쪽 최하단부 노드부터 채워집니다.
2. 새로운 노드와 부모 노드의 key 값을 비교해 교환합니다.

![image](https://user-images.githubusercontent.com/55661631/140632976-e0c832a9-025d-42e2-8d95-be114401aba7.png)

**코드**

```java
void insert_max_heap(int x) {
    
    maxHeap[++heapSize] = x; 
    // 힙 크기를 하나 증가하고, 마지막 노드에 x를 넣음
    
    for( int i = heapSize; i > 1; i /= 2) {
        
        // 마지막 노드가 자신의 부모 노드보다 크면 swap
        if(maxHeap[i/2] < maxHeap[i]) {
            swap(i/2, i);
        } else {
            break;
        }
        
    }
}
```

### 힙(Heap)에서 데이터 삭제하기

* 힙은 최대값 또는 최소값을 최상단(루트) 노드에 두고 꺼내 쓰기 위해 만들어졌기 때문에, 보통 최상단(루트) 노드를 삭제합니다.
* 최상단의 데이터 삭제 시, 힙의 마지막 노드를 최상단(루트) 노드로 이동합니다.
* 루트 노드의 값이 자식 노드보다 작을 경우, 루트 노드의 자식 노드 중 가장 큰 값을 가진 노드와 위치를 바꿔줍니다.
* 위 작업을 반복해줍니다.

![image](https://user-images.githubusercontent.com/55661631/140632980-b785b0da-320a-48e6-b9cd-bb397d201a51.png)

**코드**

```java
int delete_max_heap() {
    
    if(heapSize == 0) // 배열이 비어있으면 리턴
        return 0;
    
    int item = maxHeap[1]; // 루트 노드의 값을 저장
    maxHeap[1] = maxHeap[heapSize]; // 마지막 노드 값을 루트로 이동
    maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드 0 초기화
    
    for(int i = 1; i*2 <= heapSize;) {
        
        // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 끝
        if(maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
            break;
        }
        
        // 왼쪽 노드가 더 큰 경우, swap
        else if (maxHeap[i*2] > maxHeap[i*2+1]) {
            swap(i, i*2);
            i = i*2;
        }
        
        // 오른쪽 노드가 더 큰 경우
        else {
            swap(i, i*2+1);
            i = i*2+1;
        }
    }
    
    return item;
    
}
```

## 예상 질문 & 답변

### 자료구조 힙에 대해 설명해주세요.

최댓값 또는 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리이다.

### 자료구조 힙에서 삽입, 삭제가 일어날 때 동작 과정을 설명해주세요. (또는 코드로 작성해주세요.)

삽입 : 힙은 완전 이진 트리이므로, 데이터가 삽입되면 왼쪽 최하단부 노드부터 채워집니다. 만약, 최소 힙인 경우 새로운 노드의 키값이 부모 노드의 키값보다 작은 경우 교환되고 최대 힙은 반대일 경우 교환됩니다. 이 과정은 더 이상 교환이 일어나지 않을 때까지 반복합니다.

삭제 : 힙은 최대값 또는 최소값을 최상단(루트) 노드에 두고 꺼내 쓰기 위해 만들어졌기 때문에, 보통 최상단(루트) 노드를 삭제합니다. 최상단의 데이터 삭제 시, 힙의 마지막 노드를 최상단(루트) 노드로 이동시키고, 최대 힙일 경우 루트 노드의 값이 자식 노드보다 작으면 루트 노드의 자식 노드 중 가장 큰 값을 가진 노드와 위치를 바꿔줍니다. 이 과정을 더 이상 교환이 일어나지 않을 때까지 반복합니다.

**코드는 글을 참고해주세요.** 

### 우선순위 큐에 대해 설명해주세요.

우선순위 큐는 가장 우선 순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다.

### 우선순위 큐에 힙이 활용되는 이유를 설명해주세요.

배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n)이 걸립니다. 이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, O(log n)이 걸립니다. 따라서, 힙은 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됩니다.

## 참고
* https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%9E%99Heap
* https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Heap.md
* https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html
